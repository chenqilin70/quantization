package com.kylin.quantization.util;import java.io.*;import java.net.HttpURLConnection;import java.net.URL;import java.util.*;import java.util.stream.Collectors;import javax.activation.MimetypesFileTypeMap;import com.kylin.quantization.config.CatcherConfig;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.StringUtils;import org.apache.http.Header;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClientBuilder;import org.apache.http.message.BasicHeader;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * <b>function:</b> HTTPUtil常用工具类 包含post 和get 方法 */public class HttpUtil {	private static Logger log = LoggerFactory.getLogger(HttpUtil.class);	public static final String CHARSET = "UTF-8";	private static CloseableHttpClient httpClient;	static {		RequestConfig config = RequestConfig.custom().setConnectTimeout(60000).setSocketTimeout(60000).build();		httpClient = HttpClientBuilder.create().setDefaultRequestConfig(config).build();	}	public static String doGet(String url, Map<String, String> params) {		return doGet(url, params, CHARSET,null);	}	public static String doPost(String url, Map<String, String> params) {		return doPost(url, params, CHARSET);	}	public static String doPost(String url, String params) {		return doPost(url, params, CHARSET);	}	public static String doGetWithHead(String url, Map<String, String> params,String headPath){		Map<String, String> headersMap = CatcherConfig.proToMap(headPath);		List<BasicHeader> headers = headersMap.keySet().stream().map(k -> new BasicHeader(k, headersMap.get(k))).collect(Collectors.toList());		Header[] headersArr=new Header[headers.size()];		for(int i=0 ;i<headers.size();i++){			headersArr[i]=headers.get(i);		}		//净值日期	单位净值	累计净值	日增长率	申购状态	赎回状态	分红送配		return doGet(url, params, CHARSET, headersArr);	}	/**	 * HTTP Get 获取内容	 * 	 * @param url	 *            请求的url地址 ?之前的地址	 * @param params	 *            请求的参数	 * @param charset	 *            编码格式	 * @return 页面内容	 */	public static String doGet(String url, Map<String, String> params, String charset,Header[] headers) {		if (StringUtils.isBlank(url)) {			return null;		}		String result = null;		int tryTimes=0;		while(true){			result = null;			CloseableHttpResponse response = null;			try {				if (params != null && !params.isEmpty()) {					List<NameValuePair> pairs = new ArrayList<NameValuePair>(params.size());					for (Map.Entry<String, String> entry : params.entrySet()) {						String value = entry.getValue();						if (value != null) {							pairs.add(new BasicNameValuePair(entry.getKey(), value));						}					}					url += "?" + EntityUtils.toString(new UrlEncodedFormEntity(pairs, charset));				}				HttpGet httpGet = new HttpGet(url);				if(headers!=null){					httpGet.setHeaders(headers);				}				response = httpClient.execute(httpGet);				int statusCode = response.getStatusLine().getStatusCode();				if (statusCode != 200) {					httpGet.abort();					throw new RuntimeException("HttpClient,error status code :" + statusCode+",url:"+url);				}				HttpEntity entity = response.getEntity();				if (entity != null) {					result = EntityUtils.toString(entity, "utf-8");				}				EntityUtils.consume(entity);				break;			} catch (Exception e) {				tryTimes++;				if(tryTimes>=4){					log.error("链接尝试访问失败，第"+tryTimes+"次，即将放弃，url:"+url,e);					break;				}else{					log.error("链接尝试访问失败，第"+tryTimes+"次，即将重试，url:"+url,e);				}			}finally {				try {					if(response!=null){						response.close();					}				} catch (IOException e) {					e.printStackTrace();				}			}		}		return result;	}	/**	 * HTTP Post 获取内容	 * 	 * @param url	 *            请求的url地址 ?之前的地址	 * @param params	 *            请求的参数	 * @param charset	 *            编码格式	 * @return 页面内容	 */	public static String doPost(String url, Map<String, String> params, String charset) {		if (StringUtils.isBlank(url)) {			return null;		}		CloseableHttpResponse response = null;		try {			List<NameValuePair> pairs = null;			if (params != null && !params.isEmpty()) {				pairs = new ArrayList<NameValuePair>(params.size());				for (Map.Entry<String, String> entry : params.entrySet()) {					String value = entry.getValue();					if (value != null) {						pairs.add(new BasicNameValuePair(entry.getKey(), value));					}				}			}			HttpPost httpPost = new HttpPost(url);			if (pairs != null && pairs.size() > 0) {				httpPost.setEntity(new UrlEncodedFormEntity(pairs, CHARSET));			}			response = httpClient.execute(httpPost);			int statusCode = response.getStatusLine().getStatusCode();			if (statusCode != 200) {				httpPost.abort();				StringBuffer sb = new StringBuffer();				sb.append("类:HttpUtil,方法:doPost,error status code : ").append(statusCode).append(">>>").append(url).append(">>>").append("\n");				for(Map.Entry<String, String> en : params.entrySet()){					String key = en.getKey();					String value = en.getValue();					sb.append(key).append("=").append(value).append("\n");				}				log.error(sb.toString());				sb = null;				throw new RuntimeException();			}			HttpEntity entity = response.getEntity();			String result = null;			if (entity != null) {				result = EntityUtils.toString(entity, "utf-8");			}			EntityUtils.consume(entity);			return result;		} catch (Exception e) {			log.error(ExceptionTool.toString(e));		} finally{			if(null != response){				try {					response.close();				} catch (IOException e) {					log.error("类HttpUtil,方法doPost,response流关闭异常："+ExceptionTool.toString(e));				}			}		}		return null;	}	/**	 * 	 * 111	 * 	 * 	 * @param url	 *            请求的url地址 ?之前的地址	 * @param params	 *            请求的参数	 * @param charset	 *            编码格式	 * @return 页面内容	 */	public static String doPost(String url, String params, String charset) {		if (StringUtils.isBlank(url)) {			return null;		}		CloseableHttpResponse response = null;		try {			HttpPost httpPost = new HttpPost(url);			if (params != null && params.length() > 0) {				httpPost.setEntity(new StringEntity(params, "UTF-8"));			}			response = httpClient.execute(httpPost);			int statusCode = response.getStatusLine().getStatusCode();			if (statusCode != 200) {				httpPost.abort();				throw new RuntimeException("HttpClient,error status code :" + statusCode);			}			HttpEntity entity = response.getEntity();			String result = null;			if (entity != null) {				result = EntityUtils.toString(entity, "utf-8");			}			EntityUtils.consume(entity);			return result;		} catch (Exception e) {			e.printStackTrace();		} finally{			if(null != response){				try {					response.close();				} catch (IOException e) {					log.error("类HttpUtil,方法doPost,response流关闭异常："+ExceptionTool.toString(e));				}			}		}		return null;	}	/**	 * 上传图片	 * 	 * @param urlStr	 * @param textMap	 * @param fileMap	 * @return	 */	public static String formUpload(String urlStr, Map<String, String> textMap, Map<String, String> fileMap) {		String res = "";		HttpURLConnection conn = null;		String BOUNDARY = "---------------------------123821742118716"; // boundary就是request头和上传文件内容的分隔符		try {			URL url = new URL(urlStr);			conn = (HttpURLConnection) url.openConnection();			conn.setConnectTimeout(5000);			conn.setReadTimeout(30000);			conn.setDoOutput(true);			conn.setDoInput(true);			conn.setUseCaches(false);			conn.setRequestMethod("POST");			conn.setRequestProperty("Connection", "Keep-Alive");			conn.setRequestProperty("User-Agent", "Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN; rv:1.9.2.6)");			conn.setRequestProperty("Content-Type", "multipart/form-data; boundary=" + BOUNDARY);			OutputStream out = new DataOutputStream(conn.getOutputStream());			// text			if (textMap != null) {				StringBuffer strBuf = new StringBuffer();				Iterator iter = textMap.entrySet().iterator();				while (iter.hasNext()) {					Map.Entry entry = (Map.Entry) iter.next();					String inputName = (String) entry.getKey();					String inputValue = (String) entry.getValue();					if (inputValue == null) {						continue;					}					strBuf.append("\r\n").append("--").append(BOUNDARY).append("\r\n");					strBuf.append("Content-Disposition: form-data; name=\"" + inputName + "\"\r\n\r\n");					strBuf.append(inputValue);				}				out.write(strBuf.toString().getBytes());			}			// file			if (fileMap != null) {				Iterator iter = fileMap.entrySet().iterator();				while (iter.hasNext()) {					Map.Entry entry = (Map.Entry) iter.next();					String inputName = (String) entry.getKey();					String inputValue = (String) entry.getValue();					if (inputValue == null) {						continue;					}					File file = new File(inputValue);					String filename = file.getName();					String contentType = new MimetypesFileTypeMap().getContentType(file);					if (filename.endsWith(".png")) {						contentType = "image/png";					}					if (contentType == null || contentType.equals("")) {						contentType = "application/octet-stream";					}					StringBuffer strBuf = new StringBuffer();					strBuf.append("\r\n").append("--").append(BOUNDARY).append("\r\n");					strBuf.append("Content-Disposition: form-data; name=\"" + inputName + "\"; filename=\"" + filename							+ "\"\r\n");					strBuf.append("Content-Type:" + contentType + "\r\n\r\n");					out.write(strBuf.toString().getBytes());					DataInputStream in = new DataInputStream(new FileInputStream(file));					int bytes = 0;					byte[] bufferOut = new byte[1024];					while ((bytes = in.read(bufferOut)) != -1) {						out.write(bufferOut, 0, bytes);					}					in.close();				}			}			byte[] endData = ("\r\n--" + BOUNDARY + "--\r\n").getBytes();			out.write(endData);			out.flush();			out.close();			// 读取返回数据			StringBuffer strBuf = new StringBuffer();			BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));			String line = null;			while ((line = reader.readLine()) != null) {				strBuf.append(line).append("\n");			}			res = strBuf.toString();			reader.close();			reader = null;		} catch (Exception e) {			System.out.println("发送POST请求出错。" + urlStr);			e.printStackTrace();		} finally {			if (conn != null) {				conn.disconnect();				conn = null;			}		}		return res;	}}